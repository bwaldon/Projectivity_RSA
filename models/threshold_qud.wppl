var beliefs = ["dances","doesn't dance"]

var quds = ["MC", "CC"]


// var speaker_beliefPrior = function() {
//   return beta(4, 2)
// }

// specify utterance alternatives, only include polar interrogatives for now
var utterances = ["know-dances-?", 
                  "know-doesn't dance-?",                 
                  "think-dances-?", 
                  "think-doesn't dance-?",                         
                  "BARE-dances-?"]



// return speaker belief threshold
var predicate_thresholds = function(predicate, qud) {
  if (predicate == "know") {
    if (qud == "MC") { // if the matrix clause/predicate is at-issue
      return beta(10,1) // cannot do beta(10, 0.1): beta sample overflow
    } else { // if the qud is CC
      return beta(8,2)
    }
  }
  if (predicate == "think") {
    if (qud == "MC") {
      return beta(2,8)
    } else {
      return beta(1,10) // beta(0.1,10)
    }
  }
  else { // BARE, regardless of qud
    return beta(20,20)
  }
}

var predicate_qud = function(predicate) {
  if (predicate=="know") {
    return categorical({ps: [0.8, 0.2], vs: ["MC", "CC"]})
  }
  if (predicate=="think"){
    return categorical({ps: [0.2, 0.8], vs: ["MC", "CC"]})
  } else { // BARE
    return categorical({ps: [1, 0], vs: ["MC", "CC"]})
  }
}

display("predicate:know, qud:MC")
viz(Infer({method:"forward", samples:1000}, function(){
    return predicate_thresholds("know", "MC")
}))
display("predicate:know, qud:CC")
viz(Infer({method:"forward", samples:1000}, function(){
    return predicate_thresholds("know", "CC")
}))
display("predicate:think, qud:MC")
viz(Infer({method:"forward", samples:1000}, function(){
    return predicate_thresholds("think", "MC")
}))
display("predicate:think, qud:CC")
viz(Infer({method:"forward", samples:1000}, function(){
    return predicate_thresholds("think", "CC")
}))
display("predicate:BARE, qud:MC")
viz(Infer({method:"forward", samples:1000}, function(){
    return predicate_thresholds("BARE", "MC")
}))


// belief_prob is a tuple, the degree of speaker belief and ah belief
var meaning = function(utterance, speaker_belief, qud) {
  var splitutt = utterance.split('-')
  var predicate = splitutt[0]
  var content = splitutt[1]
  
  var threshold = predicate_thresholds(predicate, qud)
  
  if (predicate != "BARE") {
    if (!_.includes(content, "doesn't")) {
      return speaker_belief >= threshold?1:0
    } else {
      return speaker_belief <= 1 - threshold?1:0
    }
  } else {
//     var prob = Math.exp(Math.abs(threshold - speaker_belief))
    var prob = Math.pow(Math.abs(threshold - speaker_belief),0.5)
    return flip(1 - prob) ? 1:0
  }
  
}

// viz(Infer({method:"forward", samples:1000}, function(){
//     return meaning("think-dances-?", 0.2)
//  }))

var literalListener = cache(function(utterance, qud) {
  return Infer({method: 'MCMC', samples: 4000, lag: 100, burn: 50, model: function(){
//     var speaker_belief = beta(4,2)
    var speaker_belief = uniform(0,1)
    factor(meaning(utterance, speaker_belief, qud))
    return Math.trunc(Math.trunc((speaker_belief-0.01) * 100)/10) // put 1 to bin9
//     return speaker_belief
  }})
})

display("u:BARE-dances-?, qud:MC")
viz(literalListener("BARE-dances-?", "MC"))
// display("u:BARE-dances-?, qud:CC")
// viz(literalListener("BARE-dances-?", "CC"))
display("u:know-dances-?, qud:MC")
viz(literalListener("know-dances-?", "MC"))
display("u:know-dances-?, qud:CC")
viz(literalListener("know-dances-?", "CC"))
display("u:think-dances-?, qud:MC")
viz(literalListener("think-dances-?", "MC"))
display("u:think-dances-?, qud:CC")
viz(literalListener("think-dances-?", "CC"))



var alpha = 3

var cost = function(utterance){
  var embedded_cost = _.includes(utterance, "BARE") ? 0 : 0.5 
  var negation_cost = _.includes(utterance, "doesn't") ? 0 : 0.5
  return embedded_cost + negation_cost
}

// Speaker, chooses an utterance to convey a particular answer of the qud
var speaker = cache(function(speaker_belief, qud) {
  return Infer({model: function(){
    var utterance = uniformDraw(utterances)
    factor(alpha*(literalListener(utterance, qud).score(speaker_belief)) - cost(utterance)) // ignore cost for now
    return utterance
  }})
})

display("belief: 2, qud:MC")
viz(speaker(2, "MC"))
display("belief: 2, qud:CC")
viz(speaker(2, "CC"))
display("belief: 5, qud:MC")
viz(speaker(5, "MC"))
display("belief: 5, qud:CC")
viz(speaker(5, "CC"))
display("belief: 9, qud:MC")
viz(speaker(9, "MC"))
display("belief: 9, qud:CC")
viz(speaker(9, "CC"))

var pragmaticListener = function(utterance) {
  Infer({model: function() {
    var speaker_belief = uniformDraw([0,1,2,3,4,5,6,7,8,9])
    var splitutt = utterance.split('-')
    var predicate = splitutt[0]
    var qud = predicate_qud(predicate)
    observe(speaker(speaker_belief, qud), utterance)
    return {belief: speaker_belief, qud:qud}
  }})
}

display("u:know-dances-?, full + marginalized")
var know = pragmaticListener("know-dances-?")
// viz(know)
viz(marginalize(know, "belief"))
viz(marginalize(know, "qud"))

display("u:think-dances-?, full + marginalized")
var think = pragmaticListener("think-dances-?")
// viz(think)
viz(marginalize(think, "belief"))
viz(marginalize(think, "qud"))

display("u:BARE-dances-?")
var bare = pragmaticListener("BARE-dances-?")
// viz(bare)
viz(marginalize(bare, "belief"))
viz(marginalize(bare, "qud"))
