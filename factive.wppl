var quds = ["predicate", "content"]

var predicates = ["knew", "didn't know"]
var contents = ["dances", "doesn't dance"]
var utterances = ["knew dances", "didn't know dances", 
                 "knew doesn't dance", "didn't know doesn't dance",
                "dances", "doesn't dance"]
var states = ["knew dances", "didn't know dances", "knew doesn't dance", "didn't know doesn't dance"]
// var states = utterances


// the prob of the content and not the content should be: [a, 1-a] 
// where a can be obtained from behavioral result
var contentPrior = function() {
  return categorical({
    vs: contents,
    ps: [0.6, 0.4]
  })
}

var predicatePrior = function() {
  return categorical({
    vs: predicates,
    ps: [0.7, 0.3]
  })
}

var extractContent = function(utterance) {
  var firstWord = utterance.substring(0, utterance.indexOf(' '))
  if (firstWord == "knew") {
    return utterance.substring(utterance.indexOf(' ') + 1)
  } else if (firstWord == "didn't") {
    var neg = utterance.substring(utterance.indexOf(' '))
    return neg.substring(utterance.indexOf(' '))
  } else {
    return utterance
  }
}


var extractPredicate = function(utterance) {
  var firstWord = utterance.substring(0, utterance.indexOf(' '))
  if (firstWord == "knew") {
    return firstWord
  } else if (firstWord == "didn't") {
    var neg = utterance.substring(0, utterance.indexOf(' '))
    return neg + " know"
  } else {
    return ""
  }
}

var meaning = function(utterance, content) {
  var extractedContent = extractContent(utterance)
  return extractedContent == content
}

var qud_compatible = {
  content: utterances,
  predicate: states
}

// if the qud is content, then only check the content
// if the qud is predicate, then check if both the predicate and the content are the same
var compatibility_listener = function(qud, utterance, state) {
  var content = extractContent(state)
  if (qud == "content") {
    return meaning(utterance, content)  ? flip(0.9) : flip(0.1) 
  } else {
//     return _.includes(["knew dances", "didn't know dances", "knew doesn't dance", "didn't know doesn't dance"], utterance)
    return !_.includes(["dances", "doesn't dance"], utterance) ? utterance == state ? flip(0.99) : flip(0.01) : flip(0.1)
  }
}

var qudPrior = function(predicate) {
  if (predicate == "didn't know") {
//     display("in qudPrior suggest")
    return categorical({vs: quds, ps: [0.7, 0.3]}) 
  } else if (predicate == "knew")  {
//     display("in qudPrior knew")
    return categorical({vs:quds, ps:[0.6, 0.4]}) 
  } else  {
    return categorical({vs:quds, ps:[0.5, 0.5]})
  }
}

display("qudPrior " + qudPrior("knew"))

// Speaker optimality parameter
var alpha = 1


//  Literal listener
var literalListener = function(utterance, qud) {
  Infer({model: function() {
//     var content = uniformDraw(contents)
//     var utterance = uniformDraw(utterances)
    var state = uniformDraw(states)
//     var qudFn = qudFns[qud]
//     var qudAnswer = qudFn(state)
    condition(compatibility_listener(qud, utterance, state))
    return state
  }})
}

viz(literalListener("dances", "content"))
viz(literalListener("knew dances", "predicate"))


// Pragmatic speaker
var speaker = function(state, qud) {
  Infer({model: function() {
//     var possible_utterances = qud_compatible[qud]
//     var utterance = uniformDraw(possible_utterances)
    var utterance = uniformDraw(utterances)
//     display(utterance + " " + literalListener(utterance, qud))
//     condition(compatibility(qud, utterance))
//     var predicate = uniformDraw(predicates)
//     var state = predicate + content
//     display(state)
    factor(alpha * literalListener(utterance, qud).score(state))
    return utterance
  }})
}

viz(speaker("knew dances", "predicate"))
// viz(speaker("didin't know doesn't dance", "content"))

// Define a pragmatic listener
var pragmaticListener = function(utterance) {
  Infer({model: function() {
    var content = contentPrior()
    var predicate = extractPredicate(utterance)
//     display(predicate)
    var qud = qudPrior(predicate)
//     display(qud)
    var p = uniformDraw(predicates)
    var state = predicate + " " + content
//     display(state)
//     var state = statePrior()
    observe(speaker(state, qud), utterance)
    return extractContent(state)
  }})
}

viz.table(pragmaticListener("didn't know doesn't dance"))
