var quds = ["predicate", "content"]

var predicates = ["knew", "didn't know"]
var contents = ["dances", "doesn't dance"]
var utterances = ["knew dances", "didn't know dances", 
                 "knew doesn't dance", "didn't know doesn't dance",
                "dances", "doesn't dance"]
var states = ["knew dances", "didn't know dances", "knew doesn't dance", "didn't know doesn't dance"]


// the prob of the content and not the content should be: [a, 1-a] 
// where a can be obtained from behavioral result
var contentPrior = function() {
  return categorical({
    vs: contents,
    ps: [0.7, 0.3]
  })
}


var qud_compatible = {
  content: utterances,
  predicate: states
}


var extractContent = function(utterance) {
  var firstWord = utterance.substring(0, utterance.indexOf(' '))
  if (firstWord == "knew") {
    return utterance.substring(utterance.indexOf(' ') + 1)
  } else if (firstWord == "didn't") {
    var neg = utterance.substring(utterance.indexOf(' '))
    return neg.substring(utterance.indexOf(' '))
  } else {
    return utterance
  }
}


var extractPredicate = function(utterance) {
  var firstWord = utterance.substring(0, utterance.indexOf(' '))
  if (firstWord == "knew") {
    return firstWord
  } else if (firstWord == "didn't") {
    var neg = utterance.substring(0, utterance.indexOf(' '))
    return neg + " know"
  } else {
    return ""
  }
}

var meaning = function(utterance, content) {
  var extractedContent = extractContent(utterance)
  return extractedContent == content
}


var compatibility = function(qud, utterance, state) {
  var content = extractContent(state)
  if (qud == "content") {
    return meaning(utterance, content) ? flip(0.9) : flip()
  } else {
    return  extractPredicate(utterance)==extractPredicate(state) && meaning(utterance, content) ? 
      flip(0.9) : flip()
  }
}


var qudPrior = function(predicate) {
  if (predicate == "didn't know") {
    return categorical({vs: quds, ps: [0.8, 0.2]}) 
  } else if (predicate == "knew")  {
    return categorical({vs:quds, ps:[0.1, 0.9]}) 
  } else  {
    return categorical({vs:quds, ps:[0.5, 0.5]})
  }
}


// Speaker optimality parameter
var alpha = 1

//  Literal listener
var literalListener = function(utterance, qud) {
  Infer({model: function() {
    var state = uniformDraw(states)
    condition(compatibility(qud, utterance, state))
    return state
  }})
}

viz(literalListener("knew dances", "content"))
viz(literalListener("knew dances", "predicate"))


// Pragmatic speaker
var speaker = function(state, qud) {
  Infer({model: function() {
    var possible_utterances = qud_compatible[qud]
    var utterance = uniformDraw(possible_utterances)
    factor(alpha * literalListener(utterance, qud).score(state))
    return utterance
  }})
}

viz(speaker("knew dances", "content"))
viz(speaker("knew dances", "predicate"))

// Define a pragmatic listener
var pragmaticListener = function(utterance) {
  Infer({model: function() {
    var content = contentPrior()
    var p = uniformDraw(predicates)
    var qud = qudPrior(p)
    var state = p + " " + content
    observe(speaker(state, qud), utterance)
    return extractContent(state)
  }})
}

viz.table(pragmaticListener("knew dances"))
